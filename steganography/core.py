import time

from steganography import helper
from steganography.gpt import generate_container
from steganography.secret_key import generate_secret_key_mp, align_container_and_secret_key, fix_token_container_size
from models.pool_arguments import SecretKeyGenerationBody
from utils.constants import SYNONYM_MAP
from utils.logger import get_logger

logger = get_logger(__name__)


def encode_message(
    message: str,
    bits_per_word: int,
    additional_bits: int = 0,
    binarize: bool = True,
    container: str | None = None,
) -> (str, SYNONYM_MAP, dict[str, float]):
    """
    Encodes a message using a container-based technique.

    Args:
        message (str): The input message to be encoded.
        bits_per_word (int): How may bits per word should be encoded (No more than MAX_BITS_PER_WORD).
        additional_bits (int, optional): How many additional bits needs to be added to bits_per_word
            (No more than bits_per_word * MAX_ADDITIONAL_BITS_MULTIPLIER). Defaults to 0.
        binarize (bool, optional): If True, the input message is binarized using helper.binarize_message.
            Defaults to True.
        container (str, optional): If set container won't be generated by GPT model.

    Returns:
        Tuple[str, SYNONYM_MAP, dict[str, float]]: A tuple containing the encoded message, the synonym map,
            and a dictionary with time measurement information.

    Note:
        This function uses a container-based encoding technique to replace tokens in the input message
        with corresponding values from the generated secret key.
    """
    time_report, usage_report = {}, {}

    binary_message = helper.binarize_message(message) if binarize else message
    if additional_bits:
        chunk_size = bits_per_word + additional_bits
        binary_message_chunks = list(helper.divide_chunks(binary_message, chunk_size))
    else:
        binary_message_chunks = []

    s = time.time()
    if container is None:
        container_length = len(binary_message) // (bits_per_word + additional_bits) * 1.5
        container, usage = generate_container(container_length)
        time_report["container_generation"] = round(time.time() - s, 2)
        usage_report["container_generation"] = usage

    s = time.time()
    container_splits = helper.divide_chunks(container.split(), 5)

    secret_key_generation_body = SecretKeyGenerationBody.from_list(
        container_splits,
        bits_per_word,
        additional_bits,
        binary_message_chunks,
    )

    secret_key, usage = generate_secret_key_mp(secret_key_generation_body)
    time_report["secret_key_generation"] = round(time.time() - s, 2)
    usage_report["secret_key_generation"] = usage

    secret_key = align_container_and_secret_key(container, secret_key)

    encoded_message, current_idx = [], 0
    for token, replacement_token in zip(container.split(), secret_key):
        ends_with_special, token = helper.check_endswith_special(token)
        if helper.is_token_replacable(token, replacement_token) and current_idx < len(binary_message):  # Ingest token
            if helper.has_duplicates(replacement_token):
                encoded_message.append(token + ends_with_special)
                continue

            token, was_capital = helper.check_capitalization(token, replacement_token)
            token_container_size = len(list(replacement_token[token].keys())[0])
            message_part = binary_message[current_idx:current_idx + token_container_size]
            if len(message_part) != token_container_size:
                replacement_token[token] = fix_token_container_size(replacement_token[token], len(message_part))

            new_token = replacement_token[token][message_part]
            if was_capital:
                new_token = new_token.capitalize()

            encoded_message.append(new_token + ends_with_special)
            current_idx += token_container_size
        else:  # Skipping token
            encoded_message.append(token + ends_with_special)

    return container, " ".join(encoded_message), secret_key, time_report, usage_report


def decode_message(container: str, secret_key: SYNONYM_MAP, clean_output: bool = True) -> str:
    """
    Decode a message hidden within a container using a provided secret key.

    Args:
        container (str): The container string containing the encoded message.
        secret_key (SYNONYM_MAP): A mapping of base tokens to their synonyms and binary representations.
        clean_output (bool, optional): If True, the decoded message will be returned as plain text;
            if False, it will be returned as a binary sequence. Default is True.

    Returns:
        str: The decoded message.

    Note:
        The decoding process involves identifying and replacing base tokens with their corresponding binary sequences
        according to the provided secret_key. The decoded message is returned along with the time spent on decoding.
    """
    start_time = time.time()

    clean_encoded_message = helper.clean_container(container)
    binary_sequence, current_idx, counter = "", 0, 0
    for replacement_token in secret_key:
        base_token = list(replacement_token.keys())[0]
        mapping = sorted(
            [[k, v] for k, v in list(replacement_token.values())[0].items()],
            key=lambda x: len(x[1]),
            reverse=True
        )

        is_found = False
        for binary_data, token in mapping:
            span = clean_encoded_message[current_idx:current_idx + len(token)]
            is_end_of_word = helper.check_is_end_of_word(clean_encoded_message, current_idx + len(token))

            if helper.has_duplicates(replacement_token):
                current_idx += len(base_token) + 1
                is_found = True
                break

            if token.lower() == span.lower() and is_end_of_word:
                binary_sequence += binary_data
                current_idx += len(token) + 1
                is_found = True
                break

        counter += 1
        if not is_found:
            break

    if clean_output:
        decoded_message = helper.get_text_from_binary(binary_sequence)
    else:
        decoded_message = binary_sequence

    spent_time = time.time() - start_time
    return decoded_message, spent_time
